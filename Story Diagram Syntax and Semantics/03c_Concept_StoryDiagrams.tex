\section{Story Diagrams} \label{sec:StoryDiagrams}

\subsection{General Idea (Dietrich)}

% - combine activity diagrams and graph transformations as well as imperative, deterministic and declarative, non-deterministic languages to formally and compactly describe software behavior in terms of model transformations using an OO-based, familiar notation

The main idea behind story diagrams is to formalize UML activity diagrams
to better support model-driven software development
by means of completely modeling software structure and behavior and making the software model executable.
For that purpose, graph transformations, a well-known formalism, were chosen to formally specify behavior and have been combined with UML activity diagrams.
The result, story diagrams, is a mixture of two languages:
an imperative, deterministic language for the description of control flow, UML activity diagrams,
and a declarative, non-deterministic, object-oriented, graph-transformation-based language for the description of model modifications, so-called story patterns (see Section~\ref{sec:StoryPatterns}).
Both languages are graphical, formally defined, and use a familiar notation based on UML activity diagrams \todoall{ver. 1.5 or 1.4?} and UML object diagrams with minor modifications.

An exemplary story diagram is illustrated in Figure~\ref{fig:simpleStoryDiagram}.
This story diagram replaces calls of a given method (\emph{oldMethod}) with calls of another given method (\emph{newMethod}).

\begin{figure}[htb]
  \centering
  \includegraphics[scale=1.0]{figures/SimpleStoryDiagramExample}
  \caption{Exemplary Story Diagram -- Replace Method Calls}
  \label{fig:simpleStoryDiagram}
\end{figure}

Like UML activity diagrams, story diagrams model control flow by means of activity nodes and activity edges.
Each activity node contains a story pattern to formally specify the behavior for this node\footnote{There are
some few exceptions like activity call nodes which do not contain story patterns to specify the behavior.}.
The activity edges can carry guards.
These are either boolean expressions, e.g., checking attribute values of a matched object,
or guards used to specify decisions on whether a story pattern could be
matched or not\footnote{A story pattern is successfully matched if for each object and link variable in the pattern corresponding objects and links are found in the host graph and all specified constraints are satisfied.}.
In Figure~\ref{fig:simpleStoryDiagram} the used guards are \text[success\text] (successful matching),
\text[failure\text] (failed to completely execute a story pattern),
and \text[end\text] (activity edge points to the first activity node to be executed after a loop).
In contrast to ordinary UML activity diagrams, story diagrams, so far, do not model concurrent execution.
Thus, the language constructs \emph{fork} and \emph{join} are omitted in story diagrams.

%- Story diagrams in MDSD process, 2 worlds: stand-alone transformations and specifications of methods' behavior:
%  1. alternative (completely modeling software): model classes in class diagrams, specify their methods' behavior in story diagrams, generate executable source code (e.g. Java) or use an interpreter
%  2. alternative (specify recurring model operations/transformations for a given type of models): model only classes representing the editor's model under development (meta-model), specify modification operations of this model (adding and removing elements, analysis operations, translations to/generation of other models, etc.), need of a software that triggers the specified operations, the operations can be performed using generated code or an interpreter
%- introduce an example

Basically, there are two slightly different ways of using story diagrams in a model-driven software development process.

Originally, story diagrams were used to formally specify the behavior of methods that are defined in classes in object-oriented software development.
Calling such a method would mean to execute the story diagram that represents the method's behavior.
If for all defined methods story diagrams are specified, the software can be executed.
In this case, story diagrams specify the behavior of objects whose properties are defined by classes.
Thus, story diagrams have a \emph{this} variable representing an object (class instance) that they belong to.
This variable can be used as a starting point for the graph matching specified in a story diagram.
\tododt{add an example}

Another more flexible way of using story diagrams is to specify any kind of model transformation or operation in a story diagram without sticking this behavior to a certain class.
In contrast to the previous case, there is no \emph{this} variable that could be used as a starting point for the graph matching.
All starting nodes for the graph matching have to be provided as arguments of the story diagram call.
For this purpose, the story diagram in Figure~\ref{fig:simpleStoryDiagram} has two parameters \fe{oldMethod} and \fe{newMethod}.
The corresponding arguments of a story diagram call are assumed to be known (bound object variables) and are used as starting points for the graph matching.
This way, the operations or transformations defined by story diagrams can be used from within any other part of the developed software, like a software library would be used.
Typically, model-to-model transformations, consistency checks, or more generally speaking, recurring and object-independent operations are defined this way.
\tododt{add an example}

% - enable formal analyses to check/ensure certain behavioral software properties

In both cases the story diagrams can be used to generate executable source code or be executed using an interpreter.
Besides execution, the formally defined story diagrams can also be analyzed to guarantee certain behavioral properties.
For example, model checking can be used to check if a safety property is always met (\todoall{example!!!}) or if a critical state (\todoall{example!!!}) can ever be reached.


%\subsection{The Language Constructs in Story Diagrams (Jan/Dietrich)}\label{sec:StoryDiagrams:composition}

\begin{itemize}
%  \item Combination of an excerpt of UML 1.5 activity diagrams and story patterns (incl. example)
%  \item list the major language constructs like activity nodes and edges, guards (concrete syntax, well-formedness, and execution semantics)
%  \item name our restrictions, e.g., omition of fork and join
  \item refer to the appendix due to a complete language reference
  \item mention the grammar for story diagrams (based on grammar in diploma thesis of Thomas Klein \cite{Kle99})?
\end{itemize}


\subsection{Activities, Activity Parameters and Return Values (Dietrich)}

Since story diagrams can be seen as special UML activity diagrams, we reused the class names defined by the UML.
Thus, similar to UML activity diagrams, a story diagram is represented by a so-called activity (class \fe{Activity}).

Each story diagram can have parameters.
We distinguish \emph{in} and \emph{out} parameters,
i.e. parameters representing arguments given when a story diagram is called (\emph{in})
and parameters representing return values (\emph{out}).
Parameters can be (\emph{in}) and (\emph{out}) parameter at the same time.
The story diagram in Figure~\ref{fig:simpleStoryDiagram} has two (\emph{in}) parameters \fe{oldMethod} and \fe{newMethod}
as well as an unnamed (\emph{out}) parameter of the type \fe{Call}.

If a story diagram defines the behavior of a method, the parameters are defined by the corresponding method's signature.
In this case, the number of \emph{out} parameters is limited to one single parameter and represents the only \emph{return} value of the method and story diagram.
Besides these parameters there is another implicitly defined parameter \emph{this}
which -- similar to Java's \emph{this} keyword -- represents the object that the story diagram belongs to.

In case that a story diagram is not defining a method's behavior, it defines it's own signature explicitly with according (\emph{in}) and (\emph{out}) parameters.
The number of \emph{out} parameters is allowed to be arbitrary in this case and there is no \emph{this} parameter.

The values or objects returned after execution of a story diagram are defined by the object variable listed in the \emph{stop} activity nodes.
For example, the object matched to the object variable \fe{c} is returned by the story diagram in Figure~\ref{fig:simpleStoryDiagram} in case of a successful execution.
Otherwise, the \emph{null} reference is returned which is specified by the keyword \emph{null}.


\subsection{Activity Nodes, Activity Edges (Dietrich)}

\todoall{Story Nodes (laut Doku im Meta Modell ist ein
Story Node ``an activity node containing a story pattern'') werden in Modifying
und Matching Story Nodes unterteilt. }

A story diagram's control flow is defined by activity nodes and activity edges, similar to UML activity diagrams.
Except of a few exceptions where an activity node represents a call of another story diagram,
each node contains a story pattern to specify the corresponding behavior.
Thus, executing an activity node results in executing the corresponding story pattern.

In contrast to single story patterns, story patterns contained in activity nodes of a story diagram have another scope.
Here, you can reuse all object variables declared in a story pattern of a preceding activity node.
For example, in Figure~\ref{fig:simpleStoryDiagram}, the object variable \fe{parentClass} is reused in the following story pattern
by specifying the variable as a bound variable
(i.e. the variable does not have to be matched anymore, the object matched in the steps before is used instead).

Executing an activity node means to execute the corresponding story pattern
which means to find a subgraph with the specified properties (e.g. find objects of a certain type and with certain connections).
As a consequence, since trying to find such a subgraph can fail, each execution of an activity node can fail.
To distinguish the cases of a successful activity node execution and its failure,
the outgoing activity edges can be provided with the guards \text[success\text] and \text[failure\text].
The control flow is following the activity edge with the \emph{success} guard in case of a successful activity node execution,
i.e. a successful matching of the corresponding story pattern,
otherwise it follows the activity edge with the \emph{failure} guard.
If an outgoing activity edge has no guard, it covers both cases, success and failure.
The guards \text[success\text] and \text[failure\text] can only be used pair-wise.
The first activity node in Figure~\ref{fig:simpleStoryDiagram} has two outgoing activity edges with these guards.

A special activity node is the \emph{for-each} activity node, depicted by a cascading activity node.
The second activity node in Figure~\ref{fig:simpleStoryDiagram} is a \emph{for-each} activity node.
Such a node represents a loop where the contained story pattern is executed as often as new subgraphs can be matched
that differ from the previously matched graphs by at least one other matched object.
For example, the story pattern in the \emph{for-each} activity node in Figure~\ref{fig:simpleStoryDiagram}
is matched for each existing pair of a method (object variable \fe{anyMethod}) and corresponding call object (object variable \fe{c}).
Besides the matching itself, all \emph{destroy} and \emph{create} steps are also executed for each of these matched subgraphs.
After all these matching steps, the control flow is guided by the outgoing activity edge with the guard \text[end\text].
Each \emph{for-each} activity node has such an outgoing activity edge.
In addition, this edge can be combined with another activity edge having the guard \text[for each\text].
This edge is leading to the activity node (or e.g. a sequence of such nodes)
that is to be executed after each successful execution of the \emph{for-each} activity node.
In this case, there has to be an activity edge leading back to the \emph{for-each} activity node
to terminate the specified loop by following the \text[end\text] activity edge.



\subsection{Decision Nodes and Guards (Jan)}
- no fork and join

\subsection{Loops (Jan)}

\subsection{Story Diagram Calls (Markus)}

Story diagram calls are special nodes in a story diagram which are used to invoke other story diagrams. Similar to method calls, this reduces redundancy and promotes reuse.

As described in the previous sections, a story diagram can have an arbitrary number of in and out parameters. When calling a story diagram, concrete arguments have to be assigned to the in parameters. Consequently, if an object variable named n is bound somewhere in the story diagram, the identifier n can be used to pass this object variable as an argument to a call. Similarly, if the called story diagram has out parameters, those are implicitly bound to their respective names and can be used by specifying object variables of the same name.

In contrast to QVT \cite{QVT}, we do not explicitly model inout parameters. Instead, we allow the same objects which are passed as in parameters to be also returned as out parameters.
These objects are not bound again after the call. Instead the binding is preserved and the same object variable is used before and after the call. This is similar to the semantics of a call-by-reference parameter.

An example of a story diagram call is shown in Figure~\ref{fig:call}.

\begin{figure}[htb]
\begin{center}
  \includegraphics[width=\textwidth]{figures/StoryDiagramCall}
  \caption{Example of a story diagram call}
  \label{fig:call}
\end{center}
\end{figure}

The first story pattern in Figure~\ref{fig:call}, shows the bound object variable \fe{package}. Two new object variables \fe{class1} and \fe{class2} are bound in that pattern. The next node with the grey background is a story diagram call which is also signified by its label. Beneath the label, the name of the called story diagram is given, in this case \fe{CreateBidirectionalAssociation}. Assume that the called story diagram has two in parameters of the type \fe{Class} and one out parameter of the type \fe{Association}. The two classes that were bound in the first story pattern, \fe{class1} and \fe{class2} are passed to the call as arguments.
The result of the call is bound to the object variable \fe{assoc}. The type of this variable is determined by the out parameter type, i.e., in this case the type Association.

If a story diagram has no out parameters, the colon and the out parameters names after the parentheses are omitted (see Figure \ref{fig:SDRemoveInterfaceViolation} for an example).

%Issues for future versions:
% method calls
% polymorphic calls

\ext{
\subsection{Exception Handling (maybe not in Ver. 0.1)}
}


