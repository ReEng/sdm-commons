\section{Previous Work (Jan)}

\todomvd{This ``Short history of Fujaba'' seems odd here. Maybe we should it put at the end of the introduction?}

Story diagrams have been described first by Fischer et al. \cite{FNTZ00} and Jahnke and Z\"{u}ndorf \cite{JZ98} in 1998.
The foundations of story diagrams lay in the programmed graph rewriting systems PROGRES \cite{SWZ95} which has been developed at the University of Aachen since 1989.
Story diagrams (or story flow diagrams, as they have been called in early publications) adapt and enhance the PROGRES approach to a UML-like notation and an object-oriented data model \cite{JZ98}, using an easily comprehensible graphical syntax and well-defined semantics.
Z\"{u}ndorf \cite{Zun01} describes the syntax and semantics of early story diagrams in detail.
A graph grammar that formally describes the syntax of the control flow of story diagrams was defined by Klein \cite{Kle99}.
Story diagrams are embedded in a rigorous and systematic software development method called story driven modeling \cite{Zun01,DGZ04}.

From the beginning, there was strong tool support for story diagrams.
In December 1997 the Fujaba project started at the University of Paderborn.
A first prototype was implemented in the course of a master thesis \cite{FNT98}.
Fujaba, an acronym for ``From UML to Java And Back Again''\footnote{The acronym is derived from a preceding tool called FUCABA (''From UML to C++ And Back Again'') \cite{JZ97}.}, combines UML class diagrams, UML activity diagrams, and story diagrams to allow completely specifying the structure and behavior of software systems.
These specifications can then be executed.
For instance, Z\"{u}ndorf, Sch\"{u}rr and Winter \cite{ZSW99} describe how story diagrams can be compiled into Java code.
A first public tool demonstration of Fujaba was presented at the ICSE 2000 \cite{NNZ00}, showing advanced class and story diagram modeling facilities as well as graphical debugging and simulation.

In the following, story diagrams and Fujaba have been modified and enhanced.
Originally, story diagrams use expressions of the target programming language to define constraints, return values etc.
I.e., if a story diagram should be compiled into Java code, Java expressions must be used.
St\"{o}lzel, Zschaler and Geiger \cite{SZG07} integrated OCL into story diagrams, making them more platform-independent.
They connected Fujaba with the Dresden OCL toolkit, allowing a code generation for story diagrams including the OCL constraints.

To improve flexibility for the execution of story diagrams, Giese, Hildebrand and Seibel \cite{GHS09} present an interpreter for story diagrams.
In contrast to executing generated Java code, with this approach generated story diagrams can be executed immediately, allowing to create higher-order transformations where story diagrams are created by other story diagrams.
As interpreting in general is slower than compiling, the authors implemented a new dynamic matching policy for their interpreter.

Tichy, Meyer and Giese \cite{TMG06} identified some semantic issues in story diagrams.
First, when creating more than one element in a story pattern, the order of creation is undefined.
In general, this is no problem; however, in certain failure situations and when creating links in ordered associations, this may lead to non-deterministic behavior.
We deal with this issue as described in \todojr{Section X}.
Second, when having a link between two set variables \fe{setA} and \fe{setB}, the intuitive semantics would be to have every set element in \fe{setA} connected to every element in  \fe{setB}.
However, this is neither supported by the tools nor allowed by the formal semantics described by Z\"{u}ndorf \cite{Zun01}.
\todojr{describe solution}
Third, consider there is a class with two qualified associations (to other classes) that have each other as a qualifier.
When creating one link for each of the two qualified association in one story pattern, the first association that is created is qualified by the \fe{null} value although it could be qualified using the correct object (considering this is already bound).
We discuss this issue in \todojr{Section X}.
Forth, the set of possible bindings that match in a for-each activity may be extended by this very for-each activity, i.e., the activity changes something that makes new elements match for the for-each condition.
Thus, we clarify whether we use a \emph{pre-select} or a \emph{fresh matches} semantics for for-each activities in \todojr{Section X}.
Fifth, the authors propose that the result of a creating can be check in cases where creations may fail, e.g., due to resource constraints.
We mention this in \todojr{Section X}.

Giese and Klein extend story patterns to so called Story Decision Diagrams (SDDs) that allow to express complex safety properties \cite{GK06a} .
Second, they present Timed Story Scenario Diagrams (TSSDs) that are used to specify structural and temporal properties of systems in an integrated way \cite{KG07a}.

\todojr{Ist eigentlich nicht so wirklich wichtig f√ºr diesen TechReport. Streichen?}
Tichy et al. \cite{THH+08} describe how story diagrams can be used to describe reconfigurations of component-based architectures.
A transformation language called Component Story Diagrams is used to specify reconfiguration steps.
This language is transformed to story diagrams that can be executed to perform the actual reconfigurations.

The control flow of story diagrams is modeled explicitly.
However, in certain situations, it is useful to only implicitly define the execution order, as it may significantly improve the comprehensibility of a story diagram.
Thus, Meyers and Van Gorp \cite{MG08} propose to add a new language construct for the non-deterministic selection of a execution order.

Becker et al. present means for structuring complex transformations into several independent story diagrams which can be called in a well-defined manner \cite{BvDHR11}.
They propose inventing explicit call activities which invoke other story diagrams and also support polymorphic dispatching.
Polymorphic dispatching can also be used for the aforementioned case of non-deterministic execution order.
We adopt this proposal in \todojr{Section X}.

Until 2010, different branches of story diagrams and of Fujaba were developed, leading to severe difficulties when exchanging data due to incompatibilities.
In an effort to again unify the different branches, a task force was started in 2010.
A first result of this joint effort of the SDM community was a new unified and consolidated meta-model for story diagrams based on EMF \cite{HRvD+11}.
This new meta-model is the foundation for future projects; this technical report is also based on this meta-model.
One extension is the support for explicitly modeling expressions.
However, this is not described in detail here.



%motivation for the acronym Fujaba, \textit{F}rom \textit{U}ML to \textit{J}ava \textit{a}nd \textit{b}ack \textit{a}gain \cite{JZ97}

%story-driven modelling and story boards (roots of Fujaba) \cite{FNT98,FNTZ00,JZ98,ZSW99,DGZ04}

%story diagrams \cite{FNTZ00,Zun01}

%SD graph grammar for the construction of valid SDs (besides others) \cite{Kle99}

%Fujaba tool demo \cite{NNZ00}


%semantic issues \cite{TMG06}

%new meta-model \cite{HRvD+11}
