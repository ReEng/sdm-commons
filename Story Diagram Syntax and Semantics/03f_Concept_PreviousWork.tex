\section{Previous Work (Jan)}

\todomvd{This ``Short history of Fujaba'' seems odd here. Maybe we should put it somewhere else?}

Story diagrams have been described first by Fischer et al. \cite{FNTZ00} and Jahnke and Z\"{u}ndorf \cite{JZ98} in 1998.
The foundations of story diagrams lay in the programmed graph rewriting systems PROGRES \cite{SWZ95} which has been developed at the University of Aachen since 1989.
Story diagrams (or story flow diagrams, as they have been called in early publications) adapt and enhance the PROGRES approach to a UML-like notation and an object-oriented data model \cite{JZ98}, using an easily comprehensible graphical syntax and well-defined semantics.
Z\"{u}ndorf \cite{Zun01} describes the syntax and semantics of story diagrams in detail.
A graph grammar that formally describes the syntax of the control flow of story diagrams was defined by Klein \cite{Kle99}.

Story diagrams are embedded in a rigorous and systematic software development method called \emph{story-driven modeling} (SDM) \cite{Zun01,DGZ04}.
While existing approaches like UML focused on the specification of the static structure of software, SDM combines, amongst others, UML class diagrams, UML activity diagrams, and story diagrams to allow completely specifying the structure and behavior of software systems.
Furthermore, SDM describes how such a software specification can be derived from requirements.
First, each use-case in the requirements is refined by a set of sample scenarios defined by so-called \emph{story boards}.
A story board is a sequence of single snap shots of graph-like object structures, describing changes in these object structures.
Next, the static class structure of the system is derived from the story boards and further refined.
Given the sample scenarios, the general dynamic behavior of the system is then defined using story diagrams.
Finally, the implementation of the software system can be automatically generated from these formal models.

From the beginning, tool support for story diagrams was a main focus.
Fujaba, an acronym for ``From UML to Java And Back Again''\footnote{The acronym is derived from a preceding tool called FUCABA (''From UML to C++ And Back Again'') \cite{JZ97}.}, was the first tool which implemented the concept of story diagrams.
In December 1997, the project started at the University of Paderborn.
A first prototype was implemented in the course of a master thesis \cite{FNT98}.
As story diagrams specify the behavior of software, the execution of story diagrams is an important requirement.
For instance, Z\"{u}ndorf, Sch\"{u}rr and Winter \cite{ZSW99} describe how story diagrams can be compiled into Java code.
This code generation approach was also integrated into Fujaba.

A first public tool demonstration of Fujaba was presented at the ICSE 2000 \cite{NNZ00}, showing advanced class and story diagram modeling facilities as well as graphical debugging and simulation.

In the following, story diagrams and Fujaba have been modified and enhanced.
Originally, story diagrams use expressions of the target programming language to define constraints, return values etc.
I.e., if a story diagram should be compiled into Java code, Java expressions must be used.
St\"{o}lzel, Zschaler and Geiger \cite{SZG07} integrated OCL into story diagrams, making them more platform-independent.
They connected Fujaba with the Dresden OCL toolkit, allowing a code generation for story diagrams including the OCL constraints.

To improve flexibility for the execution of story diagrams, Giese, Hildebrand and Seibel \cite{GHS09} present an interpreter for story diagrams.
In contrast to executing generated Java code, with this approach generated story diagrams can be executed immediately.
This allows, for instance, to create higher-order transformations where story diagrams are created by other story diagrams and immediately be executed.
As interpreting in general is slower than compiling, the authors implemented a new dynamic matching policy for their interpreter.

Tichy, Meyer and Giese \cite{TMG06} identified some semantic issues in story diagrams.
First, when creating more than one element in a story pattern, the order of creation is undefined.
In general, this is no problem; however, in certain failure situations and when creating links in ordered associations, this may lead to non-deterministic behavior.
We deal with this issue as described in \todojr{Section X}.
Second, when having a link between two set variables \fe{setA} and \fe{setB}, the intuitive semantics would be to have every set element in \fe{setA} connected to every element in  \fe{setB}.
However, this is neither supported by the tools nor allowed by the formal semantics described by Z\"{u}ndorf \cite{Zun01}.
\todojr{describe solution}
Third, consider there is a class with two qualified associations (to other classes) that have each other as a qualifier.
When creating one link for each of the two qualified association in one story pattern, the first association that is created is qualified by the \fe{null} value although it could be qualified using the correct object (considering this is already bound).
We discuss this issue in \todojr{Section X}.
Forth, the set of possible bindings that match in a for-each activity may be extended by this very for-each activity, i.e., the activity changes something that makes new elements match for the for-each condition.
Thus, we clarify whether we use a \emph{pre-select} or a \emph{fresh matches} semantics for for-each activities in \todojr{Section X}.
Fifth, the authors propose that the result of a creating can be check in cases where creations may fail, e.g., due to resource constraints.
We mention this in \todojr{Section X}.

The control flow of story diagrams is modeled explicitly.
However, in certain situations, it is useful to only implicitly define the execution order, as it may significantly improve the comprehensibility of a story diagram.
Thus, Meyers and Van Gorp \cite{MG08} propose to add a new language construct for the non-deterministic selection of a execution order.

Becker et al. present means for structuring complex transformations into several independent story diagrams which can be called in a well-defined manner \cite{BvDHR11}.
They propose inventing explicit call activities which invoke other story diagrams and also support polymorphic dispatching.
Polymorphic dispatching can also be used for the aforementioned case of non-deterministic execution order.
We adopt this proposal in \todojr{Section X}.

Until 2010, different branches of story diagrams and of Fujaba were developed, leading to severe difficulties when exchanging data due to incompatibilities.
In an effort to again unify the different branches, a task force was started in 2010.
A first result of this joint effort of the SDM community was a new unified and consolidated meta-model for story diagrams based on EMF \cite{HRvD+11}.
This new meta-model is the foundation for future projects; this technical report is also based on this meta-model.
One extension is the support for explicitly modeling expressions.
However, this is not described in detail here.



%motivation for the acronym Fujaba, \textit{F}rom \textit{U}ML to \textit{J}ava \textit{a}nd \textit{b}ack \textit{a}gain \cite{JZ97}

%story-driven modelling and story boards (roots of Fujaba) \cite{FNT98,FNTZ00,JZ98,ZSW99,DGZ04}

%story diagrams \cite{FNTZ00,Zun01}

%SD graph grammar for the construction of valid SDs (besides others) \cite{Kle99}

%Fujaba tool demo \cite{NNZ00}


%semantic issues \cite{TMG06}

%new meta-model \cite{HRvD+11}
