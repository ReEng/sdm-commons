\section{Story Patterns (Christian und Marie)} \label{sec:StoryPatterns}

In this section, we introduce story patterns in more detail. We start by giving the general idea of story pattern in Section \ref{sec:StoryPatterns:storyPattern}. Thereafter, we describe the basic concepts of story pattern, namely object variables, link variables and there respective binding semantics in Sections \ref{sec:StoryPatterns:objects} to \ref{sec:StoryPatterns:binding}. Finally, we show the use of object attributes in a story pattern in Section \ref{sec:StoryPatterns:attributes}.


\subsection{Story Pattern [CH]}
\label{sec:StoryPatterns:storyPattern}

Story patterns are typed attributed graph transformation rules with inheritance (cf. Section \ref{sec:foundations:typedAttrGTS}) that may be embedded into an activity node of a story diagram (cf. Section \ref{sec:StoryDiagrams}). Using a type model as introduced in Section \ref{sec:typeGraph} enables use of inheritance and polymorphism for matching nodes and edges.
This allows for specifying graph replacement rules for object-oriented models.

Story patterns are applied according to single pushout semantics using isomorphic matchings.
For enabling a concise notation of the graph transformation, story pattern apply a short-hand notation depicting the left-hand side (LHS) and the right-hand side (RHS) in a single, annotated graph. Nodes and edges being created (or deleted) are annotated with \create (or  \destroy, respectively).

Figure \ref{fig:simpleStoryPattern} shows an example of a single story pattern that creates a new method declaration in an interface and delegates the target of a call to this new method.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1.0]{figures/SimpleStoryPattern}
  \caption{Simple Story Pattern}
  \label{fig:simpleStoryPattern}
\end{figure}

In the example, the nodes \fe{call}, \fe{interface}, and \fe{method} are bound objects (cf. Section \ref{sec:StoryPatterns:binding:states}), i.e., they are already matched. When applying the story pattern, the link from \fe{call} to \fe{method} will be deleted. Thereafter, the node \fe{methodDecl} of type \fe{Method} will be created along with the three links pointing to it. Upon creation, the attributes \fe{visibility}, \fe{abstract}, and \fe{name} are initialized with the specified values.

In a story pattern, we call all nodes and links that do not carry an annotation the \emph{core graph} of the story pattern. Then, the LHS of the story pattern consists of the core graph and all nodes and links annotated with \destroy. Accordingly, the RHS of the story pattern consists of the core graph and all node and links annotated with \create.

\subsection{Objects and Object Variables [MCP]}
\label{sec:StoryPatterns:objects}

Object variables represent the objects defined in a story pattern.
They are identified by their name.
The objects are instances of classes of the underlying classmodel (cp. Section \ref{sec:foundations:typedAttrGTS}).
Thus, the object variables are typed by classes from this model, i.e.
EClassifier objects.

The story pattern in Figure \ref{fig:simpleStoryPattern} contains four
object variables with the names \fe{call}, \fe{interface}, \fe{methodDecl}, and
\fe{method}. 
The type of an object variable is only visualized if the
variable is unbound (cf. Section \ref{sec:StoryPatterns:binding:states}). For
example the object variable \fe{methodDecl} has the type \fe{Method}.

Object variables have binding states, binding operators and binding semantics.
They are described in Section  \ref{sec:StoryPatterns:binding}.

\todomcp{Primitive Variables: concrete syntax like
object variables; binding expressions for initialization, see figure
\ref{fig:primitiveVariable}; primitive variables are typed over EDataType; they exist beyond the end of the Activity}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.6]{figures/PrimitiveVariable}
  \caption{Primitive variable with value assignment}
  \label{fig:primitiveVariable}
\end{figure}


\subsection{Links and Link Variables [MCP]}
\label{sec:StoryPatterns:links}

Link variables are used to connect different object variables. 
A link variable is typed over an EReference object of the underlying
classmodel.

Like object variables, link variables also have binding states, binding
operators and binding semantics (cf. Section \ref{sec:StoryPatterns:binding}).

\todomcp{binding state (unbound/bound) of link variables?}

\todomcp{Links to primitive variables: special LinkVariable, typed over
EStructuralFeature}

\subsection{Binding of Variables [MCP]}
\label{sec:StoryPatterns:binding}

Object variables and link variables have binding states (unbound, bound, maybe
bound), binding semantics (mandatory, negative, optional), and binding operators
(check only, create, destroy).


\subsubsection{Binding States}
\label{sec:StoryPatterns:binding:states}
An object variable or a link variable can either be bound, unbound, or maybe
bound. This is defined by the binding state. 
An unbound variable will be matched during the execution of the containing story
pattern. 
Even if the variable was already matched earlier in the story diagram, the
pattern matching algorithm is forced to find a new object for this variable.
A bound variable must have been matched previously. 
For a variable that is specified as maybe bound, a new match will only be
determined if it has not been bound before. 
Otherwise it will be treated as a bound variable.
The variable scope is limitted by the surrounding activity. 
That means a bound variable keeps its binding until the activity ends, unless
it has been matched again in the meantime.
An exception is the variable scope inside an each activity node (cf. Section
\label{sec:StoryDiagrams:composition}).

Unbound objects are visualized with a label of the form ``name:type'', while
the type is hidden for bound objects.

In a valid, interpretable story pattern, each connected component must contain
at least one bound object variable.

\todomcp{bindings states for links}

\todomcp{concrete syntax of maybe bound objects?}

\subsubsection{Binding Semantics}
\label{sec:StoryPatterns:binding:semantics}
Furthermore, object variables and link variables have binding semantics that
determine if a variable is mandatory, negative or optional.
Mandatory variables must exist in the given host graph, otherwise the pattern
fails. 
In contrast, negative variables must not exist in the host graph. If a variable
defined as negative can be matched during the execution of the story pattern,
the pattern fails, too.
Optional variables may exist. If an optional variable exists, it will be
bound, but if it does not exist, the story pattern may also be matched
successfully.

Negative variables are visualized crossed-out (cf. Figure
\ref{fig:bindingSemanticsOverview} b) and optional variables are visualized with
a dashed border (cf. Figure \ref{fig:bindingSemanticsOverview} c).
The same holds for negative and optional link variables (cf. Figure
\ref{fig:bindingSemanticsOverview} e+f).

Negative and optional object variables and link variables are not part of a
connected components. Regarding the rule that each connected component must contain
at least one bound object variable (cp. Section
\ref{sec:StoryPatterns:binding:states}), there are situations in which the
application of negative or optional object variables is not allowed. 

Figure \ref{fig:negativeObjects} shows example situations for negative objects
variables. 
For example, case a is allowed, but case b not because in the latter case the
graph is not connected.
The cases c is allowed because the object variables \fe{a} and \fe{c} are bound,
which means that each connected component has at least one bound object variables.
According to this, case d is allowed, too because \fe{a} and \fe{b} are both
bound. The cases e and f are allowed.

Similar to the application of negative object
variables, Figure \ref{fig:optionalObjects} shows some examples for the application of optional object variables. While case a is allowed, case b is not allowed because in this case the graph is not connected any more.
However, case c and d are allowed because each connected component contain at
least one bound object variable.
Case e and f are allowed.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1.2]{figures/BindingSemanticsOverview}
  \caption{Binding Semantics for object and link variables}
  \label{fig:bindingSemanticsOverview}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1]{figures/negativeObjects}
  \caption{Negative Application Conditions}
  \label{fig:negativeObjects}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1]{figures/optionalObjects}
  \caption{Optional Object Variables}
  \label{fig:optionalObjects}
\end{figure}

\subsubsection{Binding Operators}
\label{sec:StoryPatterns:binding:operators}
Binding operators define whether an element or link is to be created, deleted,
or just matched.
After all elements that are defined to be deleted or just matched have been
matched, the model is modified by deleting and creating the elements as
defined.

Elements or links to be created are marked with the
label \create (cf. Figure \ref{fig:bindingOperatorsOverview} b+e) and elements
to be deleted are marked with the label \destroy (cf. Figure
\ref{fig:bindingOperatorsOverview} c+f).

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1.2]{figures/BindingOperatorsOverview}
  \caption{Binding Operators for object and link variables}
  \label{fig:bindingOperatorsOverview}
\end{figure}

\subsubsection{Feasible Binding Combinations}

Binding states, binding semantics and binding operators can be
arbitrarily combined, but only certain combinations are feasible. 
Table \ref{tab:bindingCombinations} shows which binding combinations may be
used with object variables.
As depicted there, bound and maybe bound object variables must not have negative
or optional binding semantics. As well, the combination of the binding states
bound or maybe bound and the binding operator create is not allowed.

% Table generated by Excel2LaTeX from sheet 'Tabelle1'
\begin{table}[htbp]
  \centering
  \caption{Feasible combinations of binding operators, binding states, and
  binding semantics for object variables}
    \begin{tabular}{|r|r|r|r|}
    \hline
    \textbf{Binding State} & \textbf{Binding Semantics} & \textbf{Binding
    Operator} & \textbf{Feasible} \\
    \hline
    UNBOUND & MANDATORY & CHECK\_ONLY & yes \\
    UNBOUND & MANDATORY & CREATE & yes \\
    UNBOUND & MANDATORY & DESTROY & yes \\
    UNBOUND & NEGATIVE & CHECK\_ONLY & yes \\
    UNBOUND & NEGATIVE & CREATE & no \\
    UNBOUND & NEGATIVE & DESTROY & no \\
    UNBOUND & OPTIONAL & CHECK\_ONLY & yes \\
    UNBOUND & OPTIONAL & CREATE & yes \\
    UNBOUND & OPTIONAL & DESTROY & yes \\
    \hline
    BOUND & MANDATORY & CHECK\_ONLY & yes \\
    BOUND & MANDATORY & CREATE & no \\
    BOUND & MANDATORY & DESTROY & yes \\
    BOUND & NEGATIVE & CHECK\_ONLY & no \\
    BOUND & NEGATIVE & CREATE & no \\
    BOUND & NEGATIVE & DESTROY & no \\
    BOUND & OPTIONAL & CHECK\_ONLY & no \\
    BOUND & OPTIONAL & CREATE & no \\
    BOUND & OPTIONAL & DESTROY & no \\
    \hline
    MAYBE\_BOUND & MANDATORY & CHECK\_ONLY & yes \\
    MAYBE\_BOUND & MANDATORY & CREATE & no \\
    MAYBE\_BOUND & MANDATORY & DESTROY & yes \\
    MAYBE\_BOUND & NEGATIVE & CHECK\_ONLY & no \\
    MAYBE\_BOUND & NEGATIVE & CREATE & no \\
    MAYBE\_BOUND & NEGATIVE & DESTROY & no \\
    MAYBE\_BOUND & OPTIONAL & CHECK\_ONLY & no \\
    MAYBE\_BOUND & OPTIONAL & CREATE & no \\
    MAYBE\_BOUND & OPTIONAL & DESTROY & no \\
    \hline
    \end{tabular}%
  \label{tab:bindingCombinations}%
\end{table}%

\todomcp{see albert's habil for example for optional-create}
\todomcp{table for link variables and for object set variables?}

\subsection{Using Object Attributes [CH]}
\label{sec:StoryPatterns:attributes}

The objects of our host graph carries attributes. During the application of a story pattern, these attributes may be used twofold. First, constraints may be specified on the attributes to restrict the possible matches of a story pattern. Second, attribute values may be changed during the graph rewriting step.

In story pattern, we may restrict the matchings of nodes to objects of the host graph that have specific attribute values. We achieve this by so-called \emph{object constraints}. Such object constraints are considered to be part of the LHS and do not change the host graph. Figure \ref{fig:objectConstraint} shows an example.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1]{figures/ObjectConstraint}
  \caption{Matching with an Object Constraint}
  \label{fig:objectConstraint}
\end{figure}

In the example, we match a method being contained the class \fe{class}. The match is restricted to a method which has a name that equals variable \emph{methodDecl.name}.

The values of attributes that are not restricted by an object constraint are not considered during the matching. Thus, they may have an arbitrary value. In the current version of story pattern, such object constraints need to be specified using OCL. Besides equality checks, all comparative operations on the attributes of the object supported by OCL may be used as object constraints. OCL statements, however, that traverse the references of the objects are not to be used but modeled as part of the story pattern.

Beside object constraints, we may also use \emph{attribute assignments} to change the value of an attribute during the application of the story pattern. Thus, attribute assignments are considered to be part of the RHS. When using attribute assignments, the value of the attribute is not considered while matching the LHS to the host graph. Figure \ref{fig:attributeAssignment} shows an example.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1]{figures/AttributeAssignment}
  \caption{Using an Attribute Assignment}
  \label{fig:attributeAssignment}
\end{figure}

In the example, a method of class \fe{class} with an arbitrary name is matched. Then, the name of the method is changed to the name that equals variable \emph{methodDecl.name}. 

The concrete syntax of an attribute assignment is
\begin{lstlisting}
 <attributeAssignment> ::= #Attribute.name ':=' Expression
\end{lstlisting}
The expression is to be specified using OCL. The type of the return value of the OCL expression must be the same as the type of the attribute. Since the attribute assignment is considered to be part of the RHS, it is visualized in green color.


\subsection{Object Sets [MCP]}

explain objectSetVariables, set size expressions

\todomcp{object sets and binding operators/states/semantics}

\todomcp{If we bind an object set, can we use the bound object in other story pattern? E.g. to insert all elements bound by the object set into a container via a containment link? (See Figure \ref{fig:reuseObjSet}).}
\tododt{Yes, but I would use another concrete syntax (see Figures~\ref{fig:reuseObjSet1}, \ref{fig:reuseObjSet2}, and \ref{fig:reuseObjSet1}).}

\begin{figure}[p]
	\begin{minipage}{.45\textwidth}
		\centering
		\includegraphics[scale=.8]{figures/ReuseObjectSet}
  	\caption{Reusing Object Sets}
  	\label{fig:reuseObjSet}
	\end{minipage}
  \hfill
  \begin{minipage}{.45\textwidth}
  	\centering
		\includegraphics[scale=.8]{figures/ReuseObjectSet1}
  	\caption{Reuse objects in a set}
  	\label{fig:reuseObjSet1}
	\end{minipage}
\end{figure}

\begin{figure}[p]
	\begin{minipage}{.45\textwidth}
		\centering
		\includegraphics[scale=.8]{figures/ReuseObjectSet2}
  	\caption{Add an object to a set}
  	\label{fig:reuseObjSet2}
	\end{minipage}
  \hfill
  \begin{minipage}{.45\textwidth}
  	\centering
		\includegraphics[scale=.8]{figures/ReuseObjectSet3}
  	\caption{Add all objects from a set to a container}
  	\label{fig:reuseObjSet3}
	\end{minipage}
\end{figure}

\todomcp{An object set contains no ObjectSetSizeExpression and no object is matched into the object set: ObjectSet is interpreted as optional and the matching succeeds.}

\todomcp{All operators for comparison are allowed: <, <=, >, >=, = !=}


\begin{figure}[p]
	\begin{minipage}{.45\textwidth}
		\centering
		\includegraphics[scale=.8]{figures/ObjectSetSize}
  	\caption{Object Set Size}
  	\label{fig:objSetSize}
	\end{minipage}
  \hfill
  \begin{minipage}{.45\textwidth}
  	\centering
		\includegraphics[scale=.8]{figures/IsomorphismInObjectSets}
  	\caption{Isomorphism in Object Sets}
  	\label{fig:isoObjSet}
	\end{minipage}
\end{figure}

\todomcp{What happens if one pattern contains two object sets that may possibly contain the same objects. Consider the pattern in Figure \ref{fig:isoObjSet}. If c1 and c2 share the same super classes, su1 and su2 contain the same objects. Is this allowed? Isomorphic matching would normally forbid this.}

\tododt{I would allow this which would comply with our isomorphic matching.
But in this case it is non-deterministic how the objects are matched to the set nodes (assuming the classes are already bound).
A maybe constraint could allow to match the same objects to both sets.}
\todojr{We decided to match set nodes without them having to be disjoint, thus, we do not enforce isomorphism for the content of two or more set variables.}

\subsection{Special Link Kinds [CH]}

\subsubsection{Inclusion Links [CH]}

\todoch{What is the semantics of a containment link? Current understanding: an element is contained in a container. What is the difference to to-many references which are containments?}
\tododt{Containment links do not correspond to any association or reference. They only describe containments of objects in containers or set nodes.}

\todoch{Which classifiers are allowed for ContainerVariables? This should not only be the EMF collection types EList and EMap. Does a ContainmentLink need a reference as a type like normal LinkVariables?}
\tododt{The contaiment links do not need any reference. I would suggest to allow any subtype of java.util.Collection (and java.util.List in case that link order constraints are used), but not java.util.Map! This is something different and needs a key for containment. Maybe we need special containment links for maps that include a key.}

\subsubsection{Paths [MCP]}

\subsubsection{Link Constraints [CH]}

\todoch{What is the concrete Syntax for this?}

\tododt{I have a suggestion in Figure~\ref{fig:linkConstraints}.}

\begin{figure}[p]
  \centering
  \includegraphics[scale=.8]{figures/LinkConstraints1}
  \caption{Link order constraints FIRST and DIRECT\_SUCCESSOR}
  \label{fig:linkConstraints}
\end{figure}

Link constraints are only applicable to link variables that reference an ordered to-many reference.
\todoch{No link constraints for inclusion links.}

\begin{itemize}
  \item FIRST = matches the first element in the list, requires one link variable
  \item LAST = matches the last element in the list, requires one link variable
%  \item INDEX = matches the element at the specified index, requires one link variable
%  \todoch{Our lowest index value is 0, not 1.}
  \item DIRECT\_SUCCESSOR = requires two link variables, target of the second one must be located directly after the target of the first one in the list
  \item SUCCESSOR = requires two link variables, target of the second one must be located somewhere after the target of the first one in the list
\end{itemize}

\todojr{We will separate link constraints for single links and those for two links and their order. Stephan will make a suggestion.}

\todoch{Is this semantic description correct/complete?}

\todoall{Stephan: Following is my suggestion for link constraints.}

Link constraints specify constraints on the absolute position of an element in an ordered reference and the position of an element relative to another element. These constraints are only applicable to \emph{LinkVariables} that refer to ordered multi-valued references. Other kinds of links cannot be adorned with link constraints.

\paragraph{Link Position Constraints}

\begin{figure}[htb]
\center
\includegraphics[width=0.75\columnwidth]{figures/linkPositionConstraint1.png}
\caption{A \emph{first} link position constraint}
\label{fig:linkPositionConstraints:linkPositionConstraint1}
\end{figure}

A link position constraint specifies that the target object of the constrained link has to be the \emph{first} or the \emph{last} element in that reference. For example, in a valid match of the story pattern in Fig.~\ref{fig:linkPositionConstraints:linkPositionConstraint1}, the object matched to \emph{bx} must be also be the first element in the \emph{elements} reference of the object matched to \emph{a}. Link position constraints support only these two positions: \emph{First} and \emph{last}. If a story pattern contains multiple links that refer to the same metamodel reference and have the same source variable, only one of them may have a \emph{first} (or \emph{last}) constraint.

When link position constraints are attached to links with \destroy stereotypes, the semantics are identical, even if they are optional. For links with \create stereotype, the link's target element is inserted at the specified position. For optionally created links, the semantics is somewhat different. If the link does not yet exist, it is created. The target element is inserted at the specified position in the reference. If the link does exist but the element is not at the specified position, it is moved.

\todoall{Alternatives: 1.) Ignore link position constraints on optional-create links, 2.) add target element a second time. For unique references, this has the same effect like moving the element, in case of non-unique references, the element exists twice (or more times) in the list, afterwards.}

\begin{figure}[htb]
\center
\includegraphics[width=0.75\columnwidth]{figures/linkPositionConstraint2.png}
\caption{A negative link position constraint}
\label{fig:linkPositionConstraints:linkPositionConstraint2}
\end{figure}

A combination with negative links is also straight-forward. In a valid match of the pattern shown in Fig.~\ref{fig:linkPositionConstraints:linkPositionConstraint2}, the match of \emph{bx} must \emph{not} be the first element in the \emph{elements} reference.

\paragraph{Link Order Constraints}

\begin{figure}
\center
\includegraphics[width=0.4\columnwidth]{figures/linkOrderConstraint1.png}
\caption{A link order constraint specifies a relative order between two links.}
\label{fig:linkOrderConstraints:linkOrderConstaint1}
\end{figure}

Link order constraints specify a relative order between two links. In Fig.~\ref{fig:linkOrderConstraints:linkOrderConstaint1}, \emph{b2} must be the immediate successor of \emph{b1} in the \emph{elements} reference (depicted by \emph{\{next\}}). It is also possible to specify that \emph{b2} may be a direct or indirect successor, which is depicted by \emph{\{...\}}. Note, that then there may be multiple possible matches. Which of them is chosen is still non-deterministic.

Link order constraints can be combined straight-forwardly with \create and \destroy stereotypes. However, the combination with \create is only possible for the \emph{\{next\}} order constraint, not for \emph{\{...\}}. In case of created links, the order in the instance model is enforced accordingly.

\todoall{Do we want to allow this? This would make the choice, where an element is inserted non-deterministic.}

It is also possible to have only one of the two related links be destroyed or created. Though, it is not possible to create one link and destroy the other.

Link order constraints may not form circles or unsatisfiable story patterns (e.g., where a link is the successor of another but also has a \emph{\{first\}} link position constraint).

\begin{figure}
\center
\includegraphics[width=0.4\columnwidth]{figures/linkOrderConstraint2.png}
\caption{A link order constraint with a negative link.}
\label{fig:linkOrderConstraints:linkOrderConstaint2}
\end{figure}

Link order constraints can also be combined with negative link. However, only one of both links may be marked as negative. Otherwise, there would be nothing to relate to. For example, in the story pattern in Fig.~\ref{fig:linkOrderConstraints:linkOrderConstaint2}, \emph{b2} may not be the direct successor of \emph{b1}.

\begin{figure}
\center
\includegraphics[width=0.6\columnwidth]{figures/linkOrderConstraint3.png}
\caption{Two link order constraints with a negative link.}
\label{fig:linkOrderConstraints:linkOrderConstaint3}
\end{figure}

If there are multiple link order constraints, like in Fig.~\ref{fig:linkOrderConstraints:linkOrderConstaint3}, the semantics of the negative link is as follows: \emph{b2} must neither be the direct successor of \emph{b1} nor the direct predecessor of \emph{b3}. If one of both conditions is fulfilled, the pattern does not match.

\todoall{This should match the semantics of multiple NACs in a story pattern.}

For optionally created and destroyed links, the same applies to link order constraints like to link position constraints. Optionally destroyed link can be used straight-forwardly. An optionally created link is created if it does not exist, so that the specified order is enforced. If the link does exist but the element is not at an appropriate position, it is moved.

\subsubsection{Maybe Links}

Disables the isomorphism check for two object variables, these two object variables may be matched to the same object.

\todoch{What is the concrete Syntax? Using a special pattern constraint as proposed in Alberts Habil is very low-level. Alternative version is proposed in Figure \ref{fig:maybeLink}.}
\todoch{conrete syntax: "same?"}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=.8]{figures/MaybeLink}
  \caption{Maybe Link}
  \label{fig:maybeLink}
\end{figure}

\subsection{Pattern Constraints [CH]}

\todoch{What happens when a pattern constraint is placed inside a for each story pattern (not inside a node in that pattern)? Proposal: The particular match must fulfill the pattern constraint, if it does not fulfill the pattern constraint, the match is rejected and the iteration continues.}
\tododt{Exactly. In this case, it is a kind of post condition that has to be satisfied at the end of the matching step.}

\subsection{Pattern Fragments [MCP]}

patterns contained in other patterns, negative, semantics? review enhanced story patterns from Diss Florian Klein

\todomcp{Should contained pattern be marked as forEach? Idea for semantics: first the part of the pattern outside the forEach pattern is matched, then the forEach subpattern is applied to any match that may be located, the variables bound in a forEach subpattern may not be used in subsequent activities}

\tododt{This is somewhat confusing.
As I understand them, subpatterns are ordinary story patterns within another story pattern.
They are surrounded by a fragment box and can be labeled with a name (see Figure~\ref{fig:labeledSubPattern}).
Special types of such subpatterns are negative application condition fragments (NACs), set fragments, and optional fragments.
As far as I know, we did not plan to add $\forall$ and $\exists$ fragments, did we?
These are only used in SDDs and TSSDs which are constraint languages.
}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1.0]{figures/ContainedPattern}
  \caption{Different Kinds of Contained Patterns}
  \label{fig:containedPattern}
\end{figure}

\todomcp{Should contained pattern be marked as optional? Is currently possible in the meta-model. Idea for semantics: Whole pattern must be found, if found, variables may be used in subsequent activities, if pattern may not be found as a whole, matching still succeeds but all variables in the subpattern are not bound in subsequent activities.}
\tododt{I would say, contained patterns are mandatory in general (or are NAC/optional/set in case of the according fragment).}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1.0]{figures/SubPatterns2}
  \caption{Labeled sub pattern}
  \label{fig:labeledSubPattern}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=1.0]{figures/SubPatterns1}
  \caption{Hierarchies of NAC, set, and optional sub patterns}
  \label{fig:subPatternHierarchies}
\end{figure}

\todomcp{How deep may patterns be nested? What is the semantics of alternating binding semantics of sub-patterns, e.g. negative in optional in negative and so on.}
\tododt{I would prefer to allow arbitrarily deep nestings and would suggest to interpret the fragments in the order from outside to inside. Example (see Figure~\ref{fig:subPatternHierarchies}): You match a super class \emph{superClass} of \emph{myClass} and ensure that \emph{superClass} has no attribute. Then you you match all methods \emph{new} (outer set fragment) that have no class as their type (enclosed NAC fragment). Now you match for each of these methods all parameters (enclosed set fragment) that have \emph{myClass} as their type. Furthermore, you try to find a path from the matched \emph{new} method to a return statement (optional fragment).}



