\chapter{Execution of Story Diagrams (Stephan)}

In general, there are two possibilities to execute models: Executing them directly using an interpreter \cite{GHS09} or generating GPL code, which is either compiled or interpreted. 
\fuj can generate Java or C code from story diagrams and their accompanying class diagrams. 
Here, a story diagram describes the behavior of a single method. 
Therefore, this method and its containing class must be defined first. 
Interpreting a story diagram does not impose this restriction.
In the following sections, we describe the structure and operation principles of an interpreter for story diagrams.


\section{Interpreting Story Diagrams}

\subsection{Interpreter Architecture}

\begin{figure}[htb]
  \centering
  \includegraphics[width=1.0\columnwidth]{./figures/interpreter_packages.pdf}
  \caption{Overview of the Packages of the Interpreter}
  \label{fig:interpreter_packages}
\end{figure}

Figure~\ref{fig:interpreter_packages} shows the package structure of the SDM interpreter.
Currently, there are multiple story diagram metamodels in use that must all be supported by the interpreter. 
Therefore, the interpreter is divided into a metamodel-independent core (\emph{de.mdelab.sdm.interpreter.core}) and multiple metamodel-dependent extensions (\emph{org.storydriven.modeling.interpreter} and \emph{de.mdelab.sdm.interpreter.sde}). 
This separation of metamodel-dependent and independent parts allows for easier maintenance of the interpreter. 
The classes of the core package define a quite extensive list of generic type parameters (not shown in the subsequent class diagrams), e.g., for activity nodes, classifiers, or features. 
Subclasses in the metamodel-dependent packages replace these generic types with the concrete types defined in the respective metamodel.

Furthermore, those parts of the interpreter that depend on Eclipse are also separated (\emph{*.eclipse} packages). 
This allows to use the interpreter in stand-alone applications without Eclipse. 
In addition, the interpreters for expression languages like OCL are also separated (\emph{de.mdelab.sdm.interpreter.ocl}). 
The SDM interpreter provides an extension mechanism to add interpreters for other expression languages.

\subsubsection{SDM Interpreter}
\label{sec:sdm_interpreter}

\begin{figure}[htb]
  \centering
  \includegraphics[width=1.0\columnwidth]{./figures/interpreter_core.pdf}
  \caption{Main classes of the interpreter core}
  \label{fig:sdm_interpreter}
\end{figure}

Figure~\ref{fig:sdm_interpreter} shows the main classes of the interpreter core. 
\emph{SDMInterpreter} is the abstract superclass of all SDM interpreters. 
It is responsible for the execution of a whole story diagram. 
\emph{StoryDrivenInterpreter} and \emph{StoryDrivenEclipseInterpreter} inherit from it to implement metamodel specific functionality. 
Here, this is mostly limited to defining the concrete types to use in place of the generic types of the superclass and defining constructors with fewer parameters. 
The \emph{SDMInterpreter} provides the \emph{executeActivity()} method to execute a story diagram.

A \emph{VariableScope} is a collection of \emph{Variable}s that are valid in a specific scope.
A \emph{Variable} is a triple of the name, the classifier, and the value of the variable.
The \emph{SDMInterpreter} maintains multiple \emph{VariableScope}s, one for each activity node.
Currently, the whole story diagram forms a single scope.
All variables created in a story diagram are also valid in the whole story diagram. 
Therefore, the same scope is used for all activity nodes.
Only, when other story diagrams are called, a new variable scope is created. 
However, if additional elements are added to story diagrams, e.g., fork and join nodes, or the semantics of existing elements is changed, it is easily possible to support separate scopes for each activity node.

The \emph{ExpressionInterpreterManager} is responsible for managing the interpreters for expression languages and delegating the evaluation of an expression to the appropriate \emph{ExpressionInterpreter}. 
The \emph{evaluateExpression()} method is provided for that purpose. 
\emph{ExpressionInterpreter}s have to be registered at the \emph{ExpressionInterpreterManager} via the \emph{registerExpressionInterpreter()} method before expressions of that language can be handled. 
The \emph{EclipseExpressionInterpreterManager} performs this registration automatically. 
The plug-in \emph{de.mdelab.sdm.interpreter.eclipse} defines an extension point for \emph{ExpressionInterpreter}s. 
All interpreters extending this extension point are registered automatically by the \emph{EclipseExpressionInterpreterManager}. 
If the interpreter is not used within Eclipse, \emph{ExpressionInterpreter}s have to be registered explicitly before executing a story diagram.

The abstract class \emph{ExpressionInterpreter} only defines the \emph{evaluateExpression()} method that must be implemented by subclasses such as the \emph{OCLExpressionInterpreter} and the \emph{CallsInterpreter}. The methods performs the execution of the expression, which may have side effects, and has to return a \emph{Variable} with the return type and return value of the expression. In this methods, the current \emph{VariableScope} can also be access and modified.

The interpreter often needs to access specific properties of story diagram elements, e.g., the name of elements or incoming and outgoing edges of activity nodes.
While the interpreter core is metamodel-independent, it cannot access these properties directly but needs a facade for that purpose.
The \emph{MetamodelFacadeFactory} provides access to these facades. 
There are several interfaces for common kinds of story diagram elements (e.g., story nodes, junction nodes, object variables or link variables), which have to be implemented for specific story diagram metamodels.

A \emph{StoryPatternMatcher} is responsible for the execution of a single story pattern. 
This abstract superclass defines the methods \emph{findNextMatch()} to search for the next match of a story pattern and \emph{applyMatch()} to execute the graph transformation on the last match. 
The class \emph{StoryPatternMatcher} does not implement a particular matching strategy. 
This is done by \emph{PatternPartBasedPatternMatcher}. 
This pattern matching strategy is explained in more detail in Section~\ref{sec:story_pattern_matcher}. 


\subsubsection{Story Pattern Matcher}
\label{sec:story_pattern_matcher}

\begin{figure}[htb]
  \centering
  \includegraphics[width=1.0\columnwidth]{./figures/interpreter_storyPatternMatcher.pdf}
  \caption{Main classes of the story pattern matcher}
  \label{fig:interpreter_storyPatternMatcher}
\end{figure}

Figure~\ref{fig:interpreter_storyPatternMatcher} shows the classes of the story pattern matcher. 
Currently, only one pattern matching approach is implemented. 
The \emph{PatternPartBasedPatternMatcher} splits the story pattern into multiple \emph{PatternParts}. 
What exactly constitutes a \emph{PatternPart} is not specified in the interpreter core. 
This has to be implemented in the metamodel specific subclasses. 
Currently, the \emph{StoryDrivenPatternMatcher} enforces the following semantics: A pattern part consists either of a single variable that has no incoming or outgoing links (\emph{VariableOnlyPatternPart}), or of a single link and its adjacent object variables (\emph{StoryDrivenLinkVariablePatternPart}, \emph{StoryDrivenContainmentRelationPatternPart}, and \emph{StoryDrivenPathPatternPart} depending on the kind of link). 
This implies that a variable can be contained in more than one pattern parts. 
To implement subpatterns or complex negative application conditions, this semantics has to be modified. 
But this remains transparent to the basic \emph{PatternPartBasedPatternMatcher}.

\emph{PatternPart} defines several abstract methods:

\begin{enumerate}
	\item \emph{getMatchType()} returns whether matching the pattern parts is mandatory or optional, or whether the pattern part is a negative application condition (cf. Section~\ref{sec:StoryPatterns:binding:semantics}). 
	
	\item \emph{check()} checks whether the link exists in the instance graph, which requires that all variables of the pattern part are already bound to an instance object. 
	If this is not the case, \emph{check()} returns \emph{UNKNOWN}. 

	\item \emph{calculateMatchingCost()} provides an estimate of the cost to match a variable using the link of the pattern part. 
	This estimate can be based, e.g., on the number of elements contained in the link.
	If it is currently not possible to match this pattern part (e.g., because all variables of the pattern part are still unbound), \emph{-1} is returned.

	\item \emph{match()} implements the pattern matching for this kind of pattern part. 
	It is called after \emph{calculateMatchingCost()}. 
	To find a match, at least one variable of the pattern part has to be bound and one unbound. 
	Then, \emph{match()} tries to find matches for all unbound variables. 
	This part of the pattern matching algorithm is highly implementation specific. 
	It is not only different for different metamodels. 
	It also has to be implemented differently for different kinds of link variables.
	For example, matching an object via an ordinary \emph{LinkVariable} has to be done differently than matching via a \emph{Path} or a \emph{ContainmentRelation}.
	However, this also allows to exploit certain features of the metamodel to improve execution performance. 
	For example, \emph{StoryDrivenContainmentRelationPatternPart} uses EMF's \emph{eContainer()} method to navigate containment links in the opposite direction.	
	
	\item \emph{createElements()} creates the elements of the pattern part, that are marked with \create.
	
	\item \emph{destroyLink()} and \emph{destroyObjects()} destroy links and objects. 
	In contrast to the creation of elements, these steps are separated to ensure an orderly deletion of story pattern variables in the \emph{VariableScope}.
	\footnote{Background: There are two ways to execute story patterns with deleted elements: Destroy all links first and then all objects, or the other way round. 
	EMF also supports unidirectional references. 
	Therefore, deleting objects as implemented in \emph{EcoreUtil.delete()} is done by going from the deleted object to the root of the containment hierarchy (usually the \emph{Resource} or \emph{ResourceSet}) and searching for cross-references to the deleted object. 
	If the links are deleted first when the story pattern is executed, the destroyed object may be removed from its containment hierarchy (if a destroyed link represents this containment). 
	After that, existing cross-references to the destroyed object that are not represented by a link in the story pattern (remember that story patterns have SPO semantics) cannot be found and deleted. 
	For this reason, the interpreter first deletes all objects and then all links.}
	

\end{enumerate}


The \emph{MatchingStrategy} determines the order in which pattern parts are matched. 
The \emph{DefaultMatchingStrategy} matches pattern parts in the order of their matching cost estimates, i.e., \emph{getNextPatternPartForMatching()} returns that pattern part with the lowest cost estimate. 

There are also two additional pattern matching strategies: \emph{DefaultMatchingStrategyWithLog} and \emph{LogReproducingMatchingStrategy}. 
These are required for \emph{for-each} story nodes. 

\subsubsection{Notification Mechanism}
\label{sec:notification_mechanism}

\begin{figure}
\includegraphics[width=1.0\columnwidth]{figures/interpreter_metamodel_facades.pdf} 
\caption{Relevant classes of the interpreter's notification mechanism}
\end{figure}

The interpreter and all its components provide a notification mechanism to inform clients of all important steps during the execution of a story diagram, which is an implementation of the observer design pattern.

All active components of the interpreter (e.g., \emph{SDMInterpreter} or \emph{StoryPatternMatcher}), extend the \emph{Notifier} superclass.
\emph{Notifier} defines a reference to a \emph{NotificationEmitter}. 
This class provides an operation for each type of notification defined in \emph{NotificationTypeEnum} that creates an \emph{InterpreterNotification} and forwards it to all registered \emph{NotificationReceivers} by calling their \emph{notifyChanged()} operations. 
Clients can add their own \emph{NotificationReceiver}s to the \emph{NotificationEmitter}'s list of receivers.

By default, each \emph{Notifier} uses the default implementation in \emph{NotificationEmitter}. 
However, it is also possible to create \emph{Notifiers} with custom implementations of \emph{NotificationEmitter} to directly process notifications there or process notifications asynchronously, for example.


\subsection{Interpreting Story Diagrams}

\begin{figure}[htb]
\center
\includegraphics[scale=0.7]{figures/SDInterpreterExecution.pdf} 
\caption{Execution Scheme of the \emph{SDMInterpreter}}
\label{fig:sdmInterpreter_execution_scheme}
\end{figure}


The overall interpretation of a story diagram is a simple graph traversal algorithm.
The interpretation starts at the story diagram's \emph{StartNode} and traverses the story diagram until it reaches a \emph{StopNode}. 
All activity nodes are executed by specialized methods, which return the next activity node to execute afterwards. The activity diagram in Figure~\ref{fig:sdmInterpreter_execution_scheme} shows the overall execution scheme of the interpreter.

The interpreter is started with the \emph{executeActivity()} method.
This method creates the root \emph{VariableScope} and a \emph{Variable} for each parameter of the story diagram.
Then, the \emph{StartNode} of the story diagram is obtained and executed.

In general, the execution of activity nodes works as follows: 
First, the kind of the activity node is determined. Then, it is executed by the appropriate execution method.
\emph{StoryNode}s, \emph{JunctionNode}s, \emph{StopNode}s, and \emph{StatementNode}s require special handling.
All other kinds of activity nodes are simply skipped.
After execution of a node, the next node to execute is returned by the handling methods.
This process is repeated until a \emph{StopNode} is reached, which has no subsequent nodes.
Then, the loop terminates. The return value expressions of all outgoing parameters are evaluated and put into a map, which is returned by \emph{executeActivity()}.
This map maps the parameter names to their values.\footnote{For backward compatibility, all variables of the story diagram are currently returned, not only parameters.}

A non-for-each \emph{StoryNode} is executed using the \emph{StoryPatternMatcher} (cf. Section~\ref{sec:story_pattern_matcher}) with the \emph{DefaultMatchingStrategy}. 
It searches for a match of the story pattern and applies the graph transformation rule if a match was found. 
For for-each nodes, the process is more complex. 
If the story pattern is executed for the first time, a new \emph{StoryPatternMatcher} is created and stored in a local map for this \emph{StoryNode}. 
The pattern matcher is executed with the \emph{DefaultMatchingStrategyWithLog}, which keeps a log of the order in which elements were matched. 
If a match was found, the next activity node is returned that is connected via a for-each edge. 
The interpreter executes that node and eventually the control flow returns to the for-each node.
Now, the existing \emph{StoryPatternMatcher} is reused so that it continues pattern matching where it left of. 
This time, however, the pattern matcher uses the \emph{LogReproducingMatchingStrategy}. 
This ensures, that all elements are matched in the same order as the first time. 
For-each nodes are executed with the \emph{fresh match} semantics. 
After a match was found, the story pattern's side effects are executed immediately. 
Then, the next match is sought. 
Side-effects may influence subsequent matches, they may create new matches or eliminate existing ones. 
They may also influence they matching order if they change the number of elements in references, which changes the cost estimates (for details, see Section~\ref{sec:interpreting_story_patterns}). 
If the \emph{DefaultMatchingStrategy} would be used in each iteration of the for-each node, it may choose a different matching order in subsequent iterations. 
Due to the way how previous matches are managed, this may cause the pattern matcher to return a match multiple times or skip valid matches.
Therefore, the \emph{DefaultMatchingStrategyWithLog} is used in the first iteration of a for-each story node to log the matching order, and the \emph{LogReproducingMatchingStrategy} is used in all subsequent iterations, which matches elements in exactly the same order.

After the last iteration, when the pattern matcher did not find any more matches, the stored mapping between the \emph{StoryNode} and the pattern matcher is discarded. 
If the story diagram's control flow returns to the for-each node again, the pattern matching process starts anew.

In addition to the \emph{fresh match} semantics, it is also possible to add other execution semantics for for-each nodes, e.g., \emph{pre-select}, which searches for all matches before executing side-effects.


\subsection{Interpreting Story Patterns}
\label{sec:interpreting_story_patterns}

The execution of a single story pattern comprises three steps:
Initialization of the pattern matcher and analysis of the story pattern (Section~\ref{sec:spm_initialization}),
pattern matching (Section~\ref{sec:spm_pattern_matching}),
and pattern application (Section~\ref{sec:spm_pattern_application}).
These steps are executed in the constructor of the pattern matcher, the \emph{findNextMatch()}, and the \emph{applyMatch()} operations respectively.
\emph{findNextMatch()} can be called successively to return all matches for a story pattern one-by-one.
These operations are separated, to allow for additional operations between these phases by the user of the pattern matcher.


\subsubsection{Initialization and Pattern Analysis}
\label{sec:spm_initialization}

A \emph{StoryPatternMatcher} is instantiated for a specific story pattern. 
Therefore, the \emph{StoryPatternMatcher}'s constructor already requires the story pattern as a parameter.
In the constructor, the matcher's internal data structures are set up. 
These comprise lists of the bound and unbound pattern variables\footnote{Subsequently, we use the term \emph{pattern variable} to refer to object variables or primitive variables in a story pattern in contrast to \emph{Variable}s to refer to \emph{Variable} objects used internally by the pattern matcher.}, check and unchecked \emph{PatternPart}s, bound instance objects, the matching history, and the stack of match transactions.
The matching history is a mapping between pattern variables and lists of instance objects, that were previously bound to that pattern variable.
The match transaction stack is a stack that contains stack elements for each relevant action of the matcher.
Each time, a pattern variable is bound to an object, a link is checked, and for many more actions, an match transaction is executed and push onto the stack.
A transaction usually involves a manipulation of the internal data structures of the matcher, e.g., moving an element from the list of unbound to that of bound pattern variables.
When the matcher has to step back, these match transactions are popped from the stack and rolled back.
Furthermore, a \emph{VariableScope} has to be provided as a parameter so that the pattern matcher can access the instance model via these \emph{Variable}s. However, during the initialization phase, these \emph{Variables} are neither accessed nor modified.

After initializing these data structures, all pattern variables are inserted into the appropriate lists: Either for bound or unbound pattern variables.
Then the story pattern is divided into pattern parts.
Each unconnected pattern variable and each link variable with its connected pattern variables form a pattern part.
The matching process works on the granularity of these pattern parts.
This is the current default semantics specific for the two introduced metamodels.
This semantics can be different for other metamodels and it can be changed to support, e.g., complex (negative) application conditions.
Finally, an initial stack element is pushed onto the match transaction stack to indicate a successful initialization.


\subsubsection{Pattern Matching}
\label{sec:spm_pattern_matching}

\emph{findNextMatch()} is responsible for searching for the next valid match of the story pattern in the instance model.
The operation returns a boolean value indicating whether a match was found or not.
If a match was found, the pattern matcher's \emph{VariableScope} is manipulated accordingly.
If no match was found, the \emph{VariableScope} is left untouched.

First, \emph{findNextMatch()} checks if the match transaction stack is empty.
If so, all matches have already been found and no further matches exist.
Otherwise, there may still be matches to find.
So, now for all bound pattern variables the corresponding \emph{Variable}s are picked from the \emph{VariableScope} and checked for compatible types.
If these pattern variables also have assignment expressions or constraints, these are checked as well.
Pattern variables that are set to \emph{maybe bound} and for which a corresponding \emph{Variable} exists, are treated the same way.
All other pattern variables are unbound and are not treated specially at this time.

For each of the bound pattern variables\footnote{Here and in the rest of this chapter, ``bound'' pattern variable refers to a pattern variable that is either set to \emph{bound} or which the pattern matcher has bound to an instance object.}, their containing pattern parts are checked.




\subsubsection{Pattern Application}
\label{sec:spm_pattern_application}

%We will explain the operation principle of the story pattern matcher using the example in Figure~X.
%This story pattern creates abstract super classes for implementation classes and moves these implementation classes into a subpackage.
%That subpackage is created if necessary.
%
%First, the story pattern is split into pattern parts. Each pattern part consists of a link and its adjacent pattern variables\footnote{Subsequently, we use the term \emph{pattern variable} to refer to variables in a story pattern in contrast to \emph{Variable} to refer to \emph{Variable} objects used internally by the pattern matcher.}
%All pattern variables are sorted into lists of bound and unbound pattern variables. In the example, only \emph{pack1} is bound. 
%The other pattern variables are unbound.
%The matching process starts by analyzing all pattern parts that contain a bound pattern variable: \emph{pp1}, \emph{pp2}, and \emph{pp3}. However, \emph{pp3} only creates a link and is, therefore, not relevant for matching. In contrast, the link of \emph{pp2} is set to \emph{optional} and \create. Thus, an existing match for that pattern part has to be reused.
%
%Suppose, the story pattern is executed on the instance graph in Figure~Y. From the set of pattern parts that can be used for matching an unbound pattern variable, that pattern part is preferred that has the least matching cost (cf. method \emph{calculateMatchingCost()} in Section~\ref{sec:story_pattern_matcher}. By default, the matching cost estimate is based on the number of elements contained in the instance link. Here, \emph{pack1} is connected to two classes and one package. The cost estimate for \emph{pp1} is 2 and for \emph{pp2} 1. Therefore, \emph{pp2} is preferred.
%
%Now, \emph{pack2} is bound to instance object \emph{ip2}. 
%The constraint of \emph{pack2} is evaluated and it is not satisfied. 
%Therefore, the binding is revoked. 
%There are no more packages in the instance graph left, so matching continues with pattern part \emph{pp1}. 
%Pattern variable \emph{cl1} is bound to instance class \emph{ic1} but the constraint is not satisfied because the name of \emph{ic1} ends with \emph{'Impl'}. 
%Therefore, the binding is revoked and \emph{cl1} is bound to \emph{ic2}.
%Now, the constraint is satisfied, so the match is valid.
%
%This process repeats until a match for all pattern parts relevant for matching could be found, or the pattern matcher determines that no match exists.
%If a valid match was found, side effects of all pattern parts are executed next.
%First, all attribute assignments are evaluated and their return values are stored.
%This allows to access attribute values of deleted elements in assignments of created elements.
%Elements marked for deletion are deleted after that.
%In the example, \emph{pp1} deletes the link between \emph{pack1} and \emph{cl1}.
%Subsequently, all \create elements are created, which is the case for pattern parts \emph{pp2} (because no match was found for it), \emph{pp3}, \emph{pp4}, and \emph{pp5}.
%Finally, the results of attribute assignment expression are assigned to attributes, the names of \emph{cl1}, \emph{cl2}, and \emph{pack2} are set accordingly.


\section{Code Generation for Story Diagrams}
 We don't do it currently. Others have tried that before.\cite{GBD07}